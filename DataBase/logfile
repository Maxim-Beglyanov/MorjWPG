2022-03-14 14:20:46.255 +07 [17045] FATAL:  lock file "postmaster.pid" already exists
2022-03-14 14:20:46.255 +07 [17045] HINT:  Is another postmaster (PID 26807) running in data directory "/data/data/com.termux/files/usr/var/lib/postgresql"?
2022-03-27 08:47:47.721 +07 [14104] LOG:  starting PostgreSQL 14.2 on aarch64-unknown-linux-android, compiled by Android (7714059, based on r416183c1) clang version 12.0.8 (https://android.googlesource.com/toolchain/llvm-project c935d99d7cf2016289302412d708641d52d2f7ee), 64-bit
2022-03-27 08:47:47.725 +07 [14104] LOG:  listening on IPv4 address "127.0.0.1", port 5432
2022-03-27 08:47:47.737 +07 [14104] LOG:  listening on Unix socket "/data/data/com.termux/files/usr/tmp/.s.PGSQL.5432"
2022-03-27 08:47:47.799 +07 [14147] LOG:  database system was interrupted; last known up at 2022-03-26 20:46:57 +07
2022-03-27 08:47:48.158 +07 [14147] LOG:  database system was not properly shut down; automatic recovery in progress
2022-03-27 08:47:48.169 +07 [14147] LOG:  redo starts at 0/374B788
2022-03-27 08:47:48.169 +07 [14147] LOG:  invalid record length at 0/374B870: wanted 24, got 0
2022-03-27 08:47:48.169 +07 [14147] LOG:  redo done at 0/374B838 system usage: CPU: user: 0.00 s, system: 0.00 s, elapsed: 0.00 s
2022-03-27 08:47:48.253 +07 [14104] LOG:  database system is ready to accept connections
2022-03-27 08:54:57.465 +07 [17080] FATAL:  database "u0_a251" does not exist
2022-03-27 08:55:35.657 +07 [17390] ERROR:  relation "country" does not exist at character 15
2022-03-27 08:55:35.657 +07 [17390] STATEMENT:  SELECT * FROM Country
2022-03-27 08:55:35.836 +07 [17390] ERROR:  relation "builds_inventory" already exists
2022-03-27 08:55:35.836 +07 [17390] STATEMENT:  --
	-- Устанавливаем настройки postgresql
	--
	
	SET client_encoding = 'UTF8';
	
	
	--
	-- Удаляем таблицы
	--
	
	DROP TABLE IF EXISTS builds CASCADE;
	DROP TABLE IF EXISTS builds_needed_for_purchase CASCADE;
	DROP TABLE IF EXISTS units CASCADE;
	DROP TABLE IF EXISTS units_needed_for_purchase CASCADE;
	DROP TABLE IF EXISTS countries CASCADE;
	DROP TABLE IF EXISTS inventory_builds CASCADE;
	DROP TABLE IF EXISTS inventory_units CASCADE;
	DROP TABLE IF EXISTS income_times CASCADE; 
	
	
	--
	-- Создаем таблицы
	--
	
	CREATE TABLE builds(
	    build_id int GENERATED ALWAYS AS IDENTITY,
	    name varchar(128) UNIQUE NOT NULL,
	    price int NOT NULL,
	    description text DEFAULT '',
	    income int DEFAULT 0,
	
	    CONSTRAINT PK_builds_build_id PRIMARY KEY(build_id),
	    CONSTRAINT build_price_CHK CHECK(price>0)
	);
	
	CREATE TABLE builds_needed_for_purchase(
	    build_id int,
	    needed_build_id int,
	    count int,
	
	    CONSTRAINT FK_build_id FOREIGN KEY(build_id) REFERENCES builds(build_id) ON DELETE CASCADE,
	    CONSTRAINT FK_needed_build_id FOREIGN KEY(needed_build_id) REFERENCES builds(build_id) ON DELETE CASCADE,
	    CONSTRAINT build_needed_build_CHK CHECK(build_id <> needed_build_id),
	    CONSTRAINT PK_build_needed_build PRIMARY KEY(build_id, needed_build_id),
	    CONSTRAINT needed_build_count_CHK CHECK(count > 0)
	);
	
	CREATE TABLE units(
	    unit_id int GENERATED ALWAYS AS IDENTITY,
	    name varchar(128) UNIQUE NOT NULL,
	    price int NOT NULL,
	    description text DEFAULT '',
	    features text NOT NULL,
	
	    CONSTRAINT PK_units_unit_id PRIMARY KEY(unit_id),
	    CONSTRAINT unit_price_CHK CHECK(price>0)
	);
	
	CREATE TABLE units_needed_for_purchase(
	    unit_id int,
	    needed_build_id int,
	    count int,
	
	    CONSTRAINT FK_unit_id FOREIGN KEY(unit_id) REFERENCES units(unit_id) ON DELETE CASCADE,
	    CONSTRAINT FK_needed_build_id FOREIGN KEY(needed_build_id) REFERENCES builds(build_id) ON DELETE CASCADE,
	    CONSTRAINT PK_unit_needed_build PRIMARY KEY(unit_id, needed_build_id),
	    CONSTRAINT needed_build_count_CHK CHECK(count > 0)
	);
	
	CREATE TABLE countries(
	    country_id int GENERATED ALWAYS AS IDENTITY,
	    name varchar(128) UNIQUE NOT NULL,
	    money int DEFAULT 0,
	
	    CONSTRAINT PK_countries_country_id PRIMARY KEY(country_id)
	);
	
	CREATE TABLE builds_inventory(
	    country_id int,
	    build_id int,
	    count int,
	
	    CONSTRAINT FK_country_id FOREIGN KEY(country_id) REFERENCES countries(country_id) ON DELETE CASCADE,
	    CONSTRAINT FK_build_id FOREIGN KEY(build_id) REFERENCES builds(build_id) ON DELETE CASCADE,
	    CONSTRAINT PK_country_build PRIMARY KEY(country_id, build_id),
	    CONSTRAINT build_count_CHK CHECK(count > 0)
	);
	
	CREATE TABLE units_inventory(
	    country_id int,
	    unit_id int,
	    count int,
	
	    CONSTRAINT FK_country_id FOREIGN KEY(country_id) REFERENCES countries(country_id) ON DELETE CASCADE,
	    CONSTRAINT FK_unit_id FOREIGN KEY(unit_id) REFERENCES units(unit_id) ON DELETE CASCADE,
	    CONSTRAINT PK_country_unit PRIMARY KEY(country_id, unit_id),
	    CONSTRAINT unit_count_CHK CHECK(count > 0)
	);
	
	CREATE TABLE income_times(
	    income_time time UNIQUE NOT NULL
	);
	
	--
	-- Создаем представления
	--
	
	CREATE OR REPLACE VIEW builds_shop AS
	SELECT b.name AS build_name, b.price, b.description, b.income, n.name AS needed_build_name, count
	FROM builds b
	LEFT JOIN builds_needed_for_purchase USING(build_id)
	LEFT JOIN builds n ON builds_needed_for_purchase.needed_build_id = n.build_id; 
	
	CREATE OR REPLACE VIEW units_shop AS
	SELECT u.name AS unit_name, u.price, u.description, u.features, n.name AS needed_build_name, count
	FROM units u
	LEFT JOIN units_needed_for_purchase USING(unit_id)
	LEFT JOIN builds n ON units_needed_for_purchase.needed_build_id = n.build_id;
	
	-- 
	-- Создаем функции
	--
	
	CREATE OR REPLACE FUNCTION get_build_inventory_by_country(getting_country_id int) RETURNS TABLE(name varchar, count int, description text, income int) AS $$
	    SELECT name, count, description, income*count AS income
	    FROM builds
	    JOIN builds_inventory USING(build_id)
	    WHERE country_id = getting_country_id
	$$ LANGUAGE SQL;
	
	CREATE OR REPLACE FUNCTION get_unit_inventory_by_country(getting_country_id int) RETURNS TABLE(name varchar, count int, description text, features text) AS $$
	    SELECT name, count, description, features
	    FROM units
	    JOIN units_inventory USING(unit_id)
	    WHERE country_id = getting_country_id
	$$ LANGUAGE SQL;
	
	
	CREATE OR REPLACE FUNCTION get_income_countries() RETURNS TABLE(country_id int, income int) AS $$
	    SELECT country_id, COALESCE(SUM(income*count), 0)
	    FROM builds
	    JOIN builds_inventory USING(build_id)
	    GROUP BY country_id
	$$ LANGUAGE SQL;
	
	CREATE OR REPLACE FUNCTION get_income_country(getting_country_id int) RETURNS int AS $$
	    SELECT COALESCE(SUM(income*count), 0)
	    FROM builds
	    JOIN builds_inventory USING(build_id)
	    WHERE country_id = getting_country_id
	    GROUP BY country_id
	$$ LANGUAGE SQL;
	
	
	CREATE OR REPLACE FUNCTION get_needed_builds_for_build(customer_country_id int, build_name varchar) RETURNS TABLE(needed_build_name varchar, count int) AS $$
	    SELECT n.name, COALESCE(i.count, 0)-bn.count
	    FROM builds b
	    JOIN builds_needed_for_purchase bn USING(build_id)
	    LEFT JOIN builds n ON bn.needed_build_id = n.build_id
	    LEFT JOIN (SELECT build_id, count
	               FROM builds_inventory
	               WHERE country_id = customer_country_id) AS i ON n.build_id = i.build_id
	    WHERE b.name = build_name AND (COALESCE(i.count, 0)-bn.count) < 0;
	$$ LANGUAGE SQL;
	
	CREATE OR REPLACE FUNCTION get_needed_builds_for_unit(customer_country_id int, unit_name varchar) RETURNS TABLE(needed_build_name varchar, count int) AS $$
	    SELECT n.name, COALESCE(i.count, 0)-un.count
	    FROM units u
	    JOIN units_needed_for_purchase un USING(unit_id)
	    LEFT JOIN builds n ON un.needed_build_id = n.build_id
	    LEFT JOIN (SELECT build_id, count
	               FROM builds_inventory
	               WHERE country_id = customer_country_id) AS i ON n.build_id = i.build_id
	    WHERE u.name = unit_name AND (COALESCE(i.count, 0)-un.count) < 0;
	$$ LANGUAGE SQL;
	
	
	CREATE OR REPLACE FUNCTION get_needed_price_for_build(customer_country_id int, build_name varchar, count int) RETURNS int AS $$ 
	    SELECT (SELECT money 
	            FROM countries 
	            WHERE country_id = customer_country_id)-price*count AS needed_money
	    FROM builds
	    WHERE name = build_name
	$$ LANGUAGE SQL;
	
	CREATE OR REPLACE FUNCTION get_needed_price_for_unit(customer_country_id int, unit_name varchar, count int) RETURNS int AS $$
	    SELECT (SELECT money 
	            FROM countries
	            WHERE country_id = customer_country_id)-price*count AS needed_money
	    FROM units
	    WHERE name = unit_name
	$$ LANGUAGE SQL;
	
	--
	-- Заполняем данные в таблицы
	--
	
	INSERT INTO builds(name, price, description, income)
	VALUES
	('Завод бытовых товаров', 100, 'Продает бытовые товары и продает их', 20),
	('Мельница', 80, 'Молет муку и продает ее', 15),
	('Хлебопекарня', 100, 'Готовит из муки хлеб и продает его', 50),
	('Завод винтовок', 200, 'Создает винтовки', 0),
	('Казармы', 150, 'Здесь учат солдат', 0);
	
	INSERT INTO builds_needed_for_purchase(build_id, needed_build_id, count)
	VALUES
	(3, 2, 1),
	(5, 4, 2);
	
	INSERT INTO units(name, price, description, features)
	VALUES
	('Пехота', 3, 'Обычная пехота', 'Атака: 1, Защита: 1, Скорость: 1'),
	('Ополчение', 1, 'Набранное ополчение', 'Атака: 0.5, Защита: 0.5, Скорость: 0.2');
	
	INSERT INTO units_needed_for_purchase(unit_id, needed_build_id, count)
	VALUES
	(1, 5, 1);
	
	INSERT INTO countries(name, money)
	VALUES
	('Германия', 600),
	('Россия', 1200);
	
	INSERT INTO builds_inventory(country_id, build_id, count)
	VALUES
	(1, 1, 3),
	(1, 4, 2),
	(1, 5, 2);
	
	INSERT INTO units_inventory(country_id, unit_id, count)
	VALUES
	(1, 1, 1000),
	(1, 2, 3000),
	(2, 1, 5000),
	(2, 2, 10000);
	
2022-03-27 08:56:45.906 +07 [18271] ERROR:  relation "country" does not exist at character 15
2022-03-27 08:56:45.906 +07 [18271] STATEMENT:  SELECT * FROM Country
2022-03-27 08:56:46.278 +07 [18271] ERROR:  relation "builds_inventory" already exists
2022-03-27 08:56:46.278 +07 [18271] STATEMENT:  --
	-- Устанавливаем настройки postgresql
	--
	
	SET client_encoding = 'UTF8';
	
	
	--
	-- Удаляем таблицы
	--
	
	DROP TABLE IF EXISTS builds CASCADE;
	DROP TABLE IF EXISTS builds_needed_for_purchase CASCADE;
	DROP TABLE IF EXISTS units CASCADE;
	DROP TABLE IF EXISTS units_needed_for_purchase CASCADE;
	DROP TABLE IF EXISTS countries CASCADE;
	DROP TABLE IF EXISTS inventory_builds CASCADE;
	DROP TABLE IF EXISTS inventory_units CASCADE;
	DROP TABLE IF EXISTS income_times CASCADE; 
	
	
	--
	-- Создаем таблицы
	--
	
	CREATE TABLE builds(
	    build_id int GENERATED ALWAYS AS IDENTITY,
	    name varchar(128) UNIQUE NOT NULL,
	    price int NOT NULL,
	    description text DEFAULT '',
	    income int DEFAULT 0,
	
	    CONSTRAINT PK_builds_build_id PRIMARY KEY(build_id),
	    CONSTRAINT build_price_CHK CHECK(price>0)
	);
	
	CREATE TABLE builds_needed_for_purchase(
	    build_id int,
	    needed_build_id int,
	    count int,
	
	    CONSTRAINT FK_build_id FOREIGN KEY(build_id) REFERENCES builds(build_id) ON DELETE CASCADE,
	    CONSTRAINT FK_needed_build_id FOREIGN KEY(needed_build_id) REFERENCES builds(build_id) ON DELETE CASCADE,
	    CONSTRAINT build_needed_build_CHK CHECK(build_id <> needed_build_id),
	    CONSTRAINT PK_build_needed_build PRIMARY KEY(build_id, needed_build_id),
	    CONSTRAINT needed_build_count_CHK CHECK(count > 0)
	);
	
	CREATE TABLE units(
	    unit_id int GENERATED ALWAYS AS IDENTITY,
	    name varchar(128) UNIQUE NOT NULL,
	    price int NOT NULL,
	    description text DEFAULT '',
	    features text NOT NULL,
	
	    CONSTRAINT PK_units_unit_id PRIMARY KEY(unit_id),
	    CONSTRAINT unit_price_CHK CHECK(price>0)
	);
	
	CREATE TABLE units_needed_for_purchase(
	    unit_id int,
	    needed_build_id int,
	    count int,
	
	    CONSTRAINT FK_unit_id FOREIGN KEY(unit_id) REFERENCES units(unit_id) ON DELETE CASCADE,
	    CONSTRAINT FK_needed_build_id FOREIGN KEY(needed_build_id) REFERENCES builds(build_id) ON DELETE CASCADE,
	    CONSTRAINT PK_unit_needed_build PRIMARY KEY(unit_id, needed_build_id),
	    CONSTRAINT needed_build_count_CHK CHECK(count > 0)
	);
	
	CREATE TABLE countries(
	    country_id int GENERATED ALWAYS AS IDENTITY,
	    name varchar(128) UNIQUE NOT NULL,
	    money int DEFAULT 0,
	
	    CONSTRAINT PK_countries_country_id PRIMARY KEY(country_id)
	);
	
	CREATE TABLE builds_inventory(
	    country_id int,
	    build_id int,
	    count int,
	
	    CONSTRAINT FK_country_id FOREIGN KEY(country_id) REFERENCES countries(country_id) ON DELETE CASCADE,
	    CONSTRAINT FK_build_id FOREIGN KEY(build_id) REFERENCES builds(build_id) ON DELETE CASCADE,
	    CONSTRAINT PK_country_build PRIMARY KEY(country_id, build_id),
	    CONSTRAINT build_count_CHK CHECK(count > 0)
	);
	
	CREATE TABLE units_inventory(
	    country_id int,
	    unit_id int,
	    count int,
	
	    CONSTRAINT FK_country_id FOREIGN KEY(country_id) REFERENCES countries(country_id) ON DELETE CASCADE,
	    CONSTRAINT FK_unit_id FOREIGN KEY(unit_id) REFERENCES units(unit_id) ON DELETE CASCADE,
	    CONSTRAINT PK_country_unit PRIMARY KEY(country_id, unit_id),
	    CONSTRAINT unit_count_CHK CHECK(count > 0)
	);
	
	CREATE TABLE income_times(
	    income_time time UNIQUE NOT NULL
	);
	
	--
	-- Создаем представления
	--
	
	CREATE OR REPLACE VIEW builds_shop AS
	SELECT b.name AS build_name, b.price, b.description, b.income, n.name AS needed_build_name, count
	FROM builds b
	LEFT JOIN builds_needed_for_purchase USING(build_id)
	LEFT JOIN builds n ON builds_needed_for_purchase.needed_build_id = n.build_id; 
	
	CREATE OR REPLACE VIEW units_shop AS
	SELECT u.name AS unit_name, u.price, u.description, u.features, n.name AS needed_build_name, count
	FROM units u
	LEFT JOIN units_needed_for_purchase USING(unit_id)
	LEFT JOIN builds n ON units_needed_for_purchase.needed_build_id = n.build_id;
	
	-- 
	-- Создаем функции
	--
	
	CREATE OR REPLACE FUNCTION get_build_inventory_by_country(getting_country_id int) RETURNS TABLE(name varchar, count int, description text, income int) AS $$
	    SELECT name, count, description, income*count AS income
	    FROM builds
	    JOIN builds_inventory USING(build_id)
	    WHERE country_id = getting_country_id
	$$ LANGUAGE SQL;
	
	CREATE OR REPLACE FUNCTION get_unit_inventory_by_country(getting_country_id int) RETURNS TABLE(name varchar, count int, description text, features text) AS $$
	    SELECT name, count, description, features
	    FROM units
	    JOIN units_inventory USING(unit_id)
	    WHERE country_id = getting_country_id
	$$ LANGUAGE SQL;
	
	
	CREATE OR REPLACE FUNCTION get_income_countries() RETURNS TABLE(country_id int, income int) AS $$
	    SELECT country_id, COALESCE(SUM(income*count), 0)
	    FROM builds
	    JOIN builds_inventory USING(build_id)
	    GROUP BY country_id
	$$ LANGUAGE SQL;
	
	CREATE OR REPLACE FUNCTION get_income_country(getting_country_id int) RETURNS int AS $$
	    SELECT COALESCE(SUM(income*count), 0)
	    FROM builds
	    JOIN builds_inventory USING(build_id)
	    WHERE country_id = getting_country_id
	    GROUP BY country_id
	$$ LANGUAGE SQL;
	
	
	CREATE OR REPLACE FUNCTION get_needed_builds_for_build(customer_country_id int, build_name varchar) RETURNS TABLE(needed_build_name varchar, count int) AS $$
	    SELECT n.name, COALESCE(i.count, 0)-bn.count
	    FROM builds b
	    JOIN builds_needed_for_purchase bn USING(build_id)
	    LEFT JOIN builds n ON bn.needed_build_id = n.build_id
	    LEFT JOIN (SELECT build_id, count
	               FROM builds_inventory
	               WHERE country_id = customer_country_id) AS i ON n.build_id = i.build_id
	    WHERE b.name = build_name AND (COALESCE(i.count, 0)-bn.count) < 0;
	$$ LANGUAGE SQL;
	
	CREATE OR REPLACE FUNCTION get_needed_builds_for_unit(customer_country_id int, unit_name varchar) RETURNS TABLE(needed_build_name varchar, count int) AS $$
	    SELECT n.name, COALESCE(i.count, 0)-un.count
	    FROM units u
	    JOIN units_needed_for_purchase un USING(unit_id)
	    LEFT JOIN builds n ON un.needed_build_id = n.build_id
	    LEFT JOIN (SELECT build_id, count
	               FROM builds_inventory
	               WHERE country_id = customer_country_id) AS i ON n.build_id = i.build_id
	    WHERE u.name = unit_name AND (COALESCE(i.count, 0)-un.count) < 0;
	$$ LANGUAGE SQL;
	
	
	CREATE OR REPLACE FUNCTION get_needed_price_for_build(customer_country_id int, build_name varchar, count int) RETURNS int AS $$ 
	    SELECT (SELECT money 
	            FROM countries 
	            WHERE country_id = customer_country_id)-price*count AS needed_money
	    FROM builds
	    WHERE name = build_name
	$$ LANGUAGE SQL;
	
	CREATE OR REPLACE FUNCTION get_needed_price_for_unit(customer_country_id int, unit_name varchar, count int) RETURNS int AS $$
	    SELECT (SELECT money 
	            FROM countries
	            WHERE country_id = customer_country_id)-price*count AS needed_money
	    FROM units
	    WHERE name = unit_name
	$$ LANGUAGE SQL;
	
	--
	-- Заполняем данные в таблицы
	--
	
	INSERT INTO builds(name, price, description, income)
	VALUES
	('Завод бытовых товаров', 100, 'Продает бытовые товары и продает их', 20),
	('Мельница', 80, 'Молет муку и продает ее', 15),
	('Хлебопекарня', 100, 'Готовит из муки хлеб и продает его', 50),
	('Завод винтовок', 200, 'Создает винтовки', 0),
	('Казармы', 150, 'Здесь учат солдат', 0);
	
	INSERT INTO builds_needed_for_purchase(build_id, needed_build_id, count)
	VALUES
	(3, 2, 1),
	(5, 4, 2);
	
	INSERT INTO units(name, price, description, features)
	VALUES
	('Пехота', 3, 'Обычная пехота', 'Атака: 1, Защита: 1, Скорость: 1'),
	('Ополчение', 1, 'Набранное ополчение', 'Атака: 0.5, Защита: 0.5, Скорость: 0.2');
	
	INSERT INTO units_needed_for_purchase(unit_id, needed_build_id, count)
	VALUES
	(1, 5, 1);
	
	INSERT INTO countries(name, money)
	VALUES
	('Германия', 600),
	('Россия', 1200);
	
	INSERT INTO builds_inventory(country_id, build_id, count)
	VALUES
	(1, 1, 3),
	(1, 4, 2),
	(1, 5, 2);
	
	INSERT INTO units_inventory(country_id, unit_id, count)
	VALUES
	(1, 1, 1000),
	(1, 2, 3000),
	(2, 1, 5000),
	(2, 2, 10000);
	
2022-03-27 09:03:57.375 +07 [22729] ERROR:  column "id" does not exist at character 8
2022-03-27 09:03:57.375 +07 [22729] STATEMENT:  SELECT id
	                               FROM countries
	                               WHERE name = 'Казахстан'
2022-03-27 09:04:17.312 +07 [23012] ERROR:  column "id" does not exist at character 59
2022-03-27 09:04:17.312 +07 [23012] STATEMENT:  INSERT INTO countries(name) VALUES('Казахстан') RETURNING id
2022-03-27 15:27:58.337 +07 [24125] ERROR:  column "annotation" of relation "perf_text" does not exist at character 35
2022-03-27 15:27:58.337 +07 [24125] STATEMENT:  INSERT INTO perf_text(id, reason, annotation)
	SELECT s.id, md5(random()::text), null
	FROM generate_series(1, 10000000) AS s(id)
	ORDER BY random();
2022-03-27 16:03:44.435 +07 [24125] ERROR:  syntax error at or near "EXPLAINT" at character 1
2022-03-27 16:03:44.435 +07 [24125] STATEMENT:  EXPLAINT SELECT *
	FROM perf_text 
	WHERE reason LIKE 'bc%' AND annotation LIKE 'AB%';
2022-03-27 16:14:38.154 +07 [24125] ERROR:  syntax error at or near "a" at character 1
2022-03-27 16:14:38.154 +07 [24125] STATEMENT:  a
	explain 
	SELECT * 
	FROM perf_text 
	WHERE annotation LIKE 'ABEF%';
2022-03-27 16:16:02.954 +07 [24125] ERROR:  relation "perf_test" does not exist
2022-03-27 16:16:02.954 +07 [24125] STATEMENT:  CREATE INDEX idx_perf_text_annotation ON perf_test(annotation);
2022-03-27 16:25:42.067 +07 [24125] ERROR:  syntax error at or near "EXTENTION" at character 8
2022-03-27 16:25:42.067 +07 [24125] STATEMENT:  CREATE EXTENTION pg_trgn;
2022-03-27 16:25:52.532 +07 [24125] ERROR:  syntax error at or near "EXTENSTION" at character 8
2022-03-27 16:25:52.532 +07 [24125] STATEMENT:  CREATE EXTENSTION pg_trgn;
2022-03-27 16:26:15.680 +07 [24125] ERROR:  could not open extension control file "/data/data/com.termux/files/usr/share/postgresql/extension/pg_trgn.control": No such file or directory
2022-03-27 16:26:15.680 +07 [24125] STATEMENT:  CREATE EXTENSION pg_trgn;
2022-03-27 16:56:17.557 +07 [5179] ERROR:  database "test" is being accessed by other users
2022-03-27 16:56:17.557 +07 [5179] DETAIL:  There is 1 other session using the database.
2022-03-27 16:56:17.557 +07 [5179] STATEMENT:  DROP DATABASE test;
2022-03-27 16:57:35.493 +07 [6307] ERROR:  syntax error at or near "ls" at character 1
2022-03-27 16:57:35.493 +07 [6307] STATEMENT:  ls
	;
2022-03-27 16:58:50.323 +07 [6307] ERROR:  no schema has been selected to create in at character 14
2022-03-27 16:58:50.323 +07 [6307] STATEMENT:  CREATE TABLE chess_game(
	first_player text,
	second_player text,
	moves text[],
	final_state text[][]);
